ftrace.event {
	task.task_newtask {
		filter = "pid < 128"
		enable
	}
	kprobes.vfs_read {
		probes = "vfs_read $arg1 $arg2"
		filter = "common_pid < 200"
		enable
	}
	synthetic.initcall_latency {
		fields = "unsigned long func", "u64 lat"
		hist {
			keys = func.sym,lat
			values = lat
			sort = lat
		}
	}
	initcall.initcall_start.hist {
		keys = func;
		var.ts0 = common_timestamp.usecs
	}
	initcall.initcall_finish.hist {
		keys = func
		var.lat = common_timestamp.usecs - $ts0
		onmatch {
			event = initcall.initcall_start
			trace = initcall_latency, func, $lat
		}
	}
}

ftrace.instance {
	foo {
		tracer = "function"
		ftrace.filters = "user_*"
		cpumask = 1
		options = nosym-addr
		buffer_size = 512KB
		trace_clock = mono
		event.signal.signal_deliver.actions=snapshot
	}
	bar {
		tracer = "function"
		ftrace.filters = "kernel_*"
		cpumask = 2
		trace_clock = x86-tsc
	}
}

ftrace.alloc_snapshot

kernel {
	trace_options = sym-addr
	trace_event = "initcall:*"
	trace_buf_size = 1M
	ftrace = function
	ftrace_filter = "vfs*"
}
